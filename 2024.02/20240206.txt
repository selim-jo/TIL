# proxy vs reverse proxy
- 항해 프로젝트 당시 nginx를 적용하면서 proxy/reverse proxy에 대해 공부했던 것 같은데 다 까먹었다.
  실무중에도 proxy에 대한 얘기가 많이 나오는 것 같아 이번 기회에 잘 정리해야겠다.
- proxy란?
1) 개념: 프록시 서버는 클라이언트가 자신을 통해서 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용프로그램을 가리킴
2) 사용이유: 보안상의 이유로 직접 통신할 수 없는 두 점 사이에서 대리로 통신을 수행하여 보안성, 성능, 안정성을 향상 시키기 위해
         : 중복요청에 대한 처리를 해 클라이언트에게는 빠른 속도의 서비스를, 서버에게는 불필요한 부하를 줄이는 효과를 나타냄
3) 프록시 종류
-> 포워드 프록시 vs 리버스 프록시
: 포워드 프록시는 클라이언트 바로 뒤에 놓여있으며, 리버스 프록시는 웹서버/WAS 앞에 놓여있음
cf) 우리가 구성하는 일반적인 WEB(Apache, nginx)-WAS(Tomcat) 분리 형태를 리버스 프록시라고 보면 됨
    여기서 WEB(Apache, nginx)가 리버스 프록시가 됨
    But, 아파치 톰캣 같이 물리적인 한 서버에 WEB, WAS가 존재한다면 리버스 프록시라고 볼 수 없음
: 포워드 프록시는 내부망에서 클라이언트와 프록시 서버가 통신하여 인터넷을 통해 외부에서 데이터를 가져옴
  리버스 프록시는 내부망에서 프록시 서버와 내부망 서버가 통신하여 인터넷을 통해 요청이 들어오면 프록시 서버가 받아 응답해줌
: 포워드 프록시는 직접 서버 url로 요청을 보내지만, 리버스 프록시는 프록시 서버 url로만 접근이 가능함
  So, 리버스 프록시는 본 서버의 IP 정보를 숨길 수 있음

# @Resource vs @Autowired
- 프로젝트 및 실무를 하다보면 @Resource, @Autowired를 혼용하여 사용한다. 2개의 차이점을 잘 알고 사용해야되지 않을까해서 이번 기회에 잘 정리해야겠다.
- 일단 @Resource, @Autowired 둘 다 의존성을 주입하는 어노테이션으로 해당 어노테이션을 사용하여 IoC 컨테이너에 등록된 빈 객체를 자동으로 주입함

- @Autowired
: 필드, 메서드, 생성자에 사용할 수 있음
: Bean의 타입을 사용해서 주입할 빈 객체를 찾음
: 하나의 인터페이스는 한 개의 클래스로만 구현할 수 있음(두 개 이상의 클래스 구현x)
ex) @Service
    public class HelloService {
        @Autowired
        private A a;
    }
: 빈 객체 찾는 순서
1) 타입이 같은 빈 객체를 찾음
2) 만약 타입이 같은 빈 객체가 두 개 이상이고, @Qualifier 어노테이션이 붙어있지 않은 경우 이름이 같은 빈 객체를 찾음
3) @Qualifier(또는 @Primary) 어노테이션이 붙어있다면 해당 어노테이션으로 지정된 빈 객체를 찾음

- @Resource
: 필드, 메서드에 사용할 수 있음. 생성자에는 사용x
: Bean의 이름을 사용해서 주입할 빈 객체를 찾음
ex) @Resource(name = "memberRepository")
    private MemberRepository memberRepository;
: 빈 객체 찾는 순서
1) name 속성 값으로 지정한 빈 객체를 찾음
2) name 속성이 존재하지 않는다면 동일한 타입을 갖는 빈 객체를 찾음
3) name 속성이 존재하지 않고, 동일한 타입을 갖는 빈 객체가 두 개 이상인 경우 이름이 같은 빈 객체를 찾음
4) name 속성이 존재하지 않고, 동일한 타입을 갖는 빈 객체가 두 개 이상이고, 이름이 같은 빈객체마저도 없는 경우 @Qualifier(또는 @Primary)을 사용해서 주입할 빈 객체를 찾아야 함

# 클론 prj 이어서
- 관련 내용과 오류 Tech 노션에 기록